<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Component Installer ( prototype ) for ZF3">
  <meta name="author" content="https://mwop.net">

  <title>Component Installer (prototype) for ZF3</title>

  <!-- Bootstrap via CDN -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <!-- Optional bootstrap theme via CDN -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap-theme.min.css" integrity="sha384-fLW2N01lMqjakBkx3l/M9EahuwpSfeNvV63J5ezn3uZzapT0u7EYsXMjQV+0En5r" crossorigin="anonymous">

  <link rel="stylesheet" href="prism.css">
  <style>
    .jumbotron {
      margin-top: 3em;
    }
  </style>
</head>
<body>
  <!-- Fixed navbar -->
  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="#">Component Installer</a>
      </div>
    </div>
  </nav>

  <div class="container content" role="main">
    <div class="jumbotron">
      <h1>Component Installer</h1>

      <p>A (prototype) component installer for ZF3 components.</p>
    </div>

    <h2>Why?</h2>

    <p>
      We're planning on reducing the <em>required</em> components for the MVC and
      framework. Currently in v2, however, zend-mvc provides copious amounts of
      integrations with other components; removing them as dependencies means
      their factories, plugin managers, and event listeners will not be wired
      automatically. One proposed solution is to provide each component with a
      <code>Module</code> class that could provide those; however, one issue with
      that approach is ensuring that the components are then added to the list of
      enabled modules.
    </p>

    <p>
      The approach this package takes is to provide <a
        href="https://getcomposer.org">Composer</a> event hooks that will update
      the enabled module list when a package providing a module is installed or
      uninstalled. However, Composer has a few limitations with regards to such
      hook scripts:
    </p>

    <ul>
      <li>If the code is in a package on which the project depends, a warning
        is emitted for each package installed until the package containing the
        scripts is processed. This will likely raise a lot of support questions.</li>
      <li>If the event hook classes are present inside the project, they <em>must</em>
        be autoloadable. Additionally, the must <em>always</em> be autoloadable;
        you cannot define a <code>autoload-dev</code> rule for the
        classes/namespaces; only a production one will work.</li>
    </ul>

    <p>
      These limitations are easily accommodated for <em>new</em> projects, as we
      can include them in project skeletons. However, for those <em>migrating</em>
      to ZF3, we want to provide a mechanism for adding the scripts.
    </p>

    <p>
      The solution presented here is to provide a utility that will will copy
      the classfiles for the scripts into your project, and then manipulate the
      <code>composer.json</code> to add autoload rules for them, and to add
      entries for the event hook scripts.
    </p>

    <p>
      You have two options: using a downloadable, self-updateable PHAR, or
      installation as a global Composer package.
    </p>

    <hr />

    <h2>Get the PHAR</h2>

    <ul>
      <li><a href="zend-component-installer.phar">zend-component-installer.phar</a></li>
      <li><a href="zend-component-installer.phar.pubkey">public OpenSSL key (to verify
        the PHAR)</a></li>
    </ul>

    <p>
      You'll need to download both files, and they will need to reside together.
    </p>

    <p>
      Once downloaded, make the PHAR executable, and execute
      <kbd>zend-component-installer.phar help</kbd> to verify that it works.
    </p>

    <h3>Using the PHAR</h3>

    <pre><code class="lang-bash" data-trim>
$ zend-component-installer.phar install
# Or specify a path to a project
$ zend-component-installer.phar install /path/to/my/project
    </code></pre>

    <p>
      Once installed, whenever your install a component that implements a module,
      it will update the <code>config/application.config.php</code> file to add
      the component to the module list. Components are always added to the top of
      the list, to ensure that your own modules can override any settings they
      introduce.
    </p>

    <h3>Keeping up-to-date</h3>

    <p>
      Periodically, we may make changes to the tool. To update, you can use the
      self-update command:
    </p>

    <pre><code class="lang-bash" data-trim>
$ zend-component-installer.phar self-update
    </code></pre>

    <p>
      Two notes on this command:
    </p>

    <ul>
      <li>The self-update features require PHP 5.6 or above. This is due to the
        fact that it is doing SSL/TLS negotiation in order to both check for an
        update, as well as download the new PHAR file; PHP 5.6 is the first
        version of PHP that provides proper SSL/TLS negotiation with the shipped
        defaults. <em>You can use the installer with 5.5, just not the
        self-updater.</em></li>
      <li>The command will put a copy of the previous version of the command in
        the sibling file <code>zend-component-installer-old.phar</code>. This allows
       you to rollback to the previous version should you detect a problem.</li>
    </ul>

    <h3>Rolling back</h3>

    <p>
      When using the PHAR, you can also rollback to a previously installed
      version, if you have kept the <code>zend-component-installer-old.phar</code>
      file:
    </p>

    <pre><code class="lang-bash" data-trim>
$ zend-component-installer.phar rollback
    </code></pre>

    <hr />

    <h2>Global Composer Installation</h2>

    <p>
      You can also install the utility as a global Composer package:
    </p>

    <pre><code class="lang-bash" data-trim>
$ composer global require zendframework/zend-component-installer
    </code></pre>

    <p>
      This will install the package globally. In order to use it, the
      <code>$COMPOSER_HOME/bin</code> directory must be in your user's
      <code>$PATH</code>. From there, invocation is:
    </p>

    <pre><code class="lang-bash" data-trim>
$ zend-component-installer installer [<path>]
    </code></pre>

    <h3>Keeping up-to-date</h3>

    <p>
      To keep your utility up-to-date, periodically perform the following:
    </p>

    <pre><code class="lang-bash" data-trim>
$ composer global update zendframework/zend-component-installer
    </code></pre>

    <hr />

    <h2>Defining a component that implements a module</h2>

    <p>
      There are two things you must do to have your package opt-in to this
      workflow:
    </p>

    <ul>
      <li>The component must have a <code>Module</code> class in the namespace it
        defines.</li>
      <li>The <code>composer.json</code> must specify the component namespace in the
        <code>extra.zf</code> section:
        <pre><code class="lang-javascript" data-trim>
  "extra": {
    "zf": {
      "component": "Some\Component"
    }
  }
        </code></pre>
      </li>
    </ul>

    <p>
      Component modules are placed at the <em>top</em> of the module list, so
      that userland modules may override the defaults they provide.
    </p>

    <h2>Defining a userland module</h2>

    <p>
      There are two things you must do to have your package opt-in to this
      workflow:
    </p>

    <ul>
      <li>The module must have a <code>Module</code> class in the namespace it
        defines.</li>
      <li>The <code>composer.json</code> must specify the module namespace in the
        <code>extra.zf</code> section:
        <pre><code class="lang-javascript" data-trim>
  "extra": {
    "zf": {
      "module": "Some\Component"
    }
  }
        </code></pre>
      </li>
    </ul>

    <p>
      Userland modules are placed at the <em>bottom</em> of the module list, so
      that their settings may override component settings.
    </p>
  </div>

  <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
  <!-- Bootstrap JS via CDN -->
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
  <script src="prism.js"></script>
</body>
</html>
